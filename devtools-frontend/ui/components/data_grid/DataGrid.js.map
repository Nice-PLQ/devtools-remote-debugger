{"version":3,"file":"DataGrid.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/data_grid/DataGrid.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Host from '../../../core/host/host.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as UI from '../../legacy/legacy.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nimport dataGridStyles from './dataGrid.css.js';\nimport {BodyCellFocusedEvent, ColumnHeaderClickEvent, ContextMenuHeaderResetClickEvent} from './DataGridEvents.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nimport {addColumnVisibilityCheckboxes, addSortableColumnItems} from './DataGridContextMenuUtils.js';\nimport type {CellPosition, Column, Row, SortState} from './DataGridUtils.js';\nimport {calculateColumnWidthPercentageFromWeighting, calculateFirstFocusableCell, getRowEntryForColumnId, handleArrowKeyNavigation, renderCellValue, SortDirection} from './DataGridUtils.js';\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nconst UIStrings = {\n  /**\n  *@description A context menu item in the Data Grid of a data grid\n  */\n  sortBy: 'Sort By',\n  /**\n  *@description A context menu item in data grids to reset the columns to their default weight\n  */\n  resetColumns: 'Reset Columns',\n  /**\n  *@description A context menu item in data grids to list header options.\n  */\n  headerOptions: 'Header Options',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport interface DataGridContextMenusConfiguration {\n  headerRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[]) => void;\n  bodyRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[], row: Readonly<Row>) => void;\n}\n\nexport interface DataGridData {\n  columns: Column[];\n  rows: Row[];\n  activeSort: SortState|null;\n  contextMenus?: DataGridContextMenusConfiguration;\n}\n\nconst enum UserScrollState {\n  NOT_SCROLLED = 'NOT_SCROLLED',\n  MANUAL_SCROLL_NOT_BOTTOM = 'MANUAL_SCROLL_NOT_BOTTOM',\n  SCROLLED_TO_BOTTOM = 'SCROLLED_TO_BOTTOM',\n}\n\nconst KEYS_TREATED_AS_CLICKS = new Set([' ', 'Enter']);\n\nconst ROW_HEIGHT_PIXELS = 18;\nconst PADDING_ROWS_COUNT = 10;\n\nexport class DataGrid extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-data-grid`;\n\n  private readonly shadow = this.attachShadow({mode: 'open'});\n  private columns: readonly Column[] = [];\n  private rows: readonly Row[] = [];\n  private sortState: Readonly<SortState>|null = null;\n  private isRendering = false;\n  private userScrollState: UserScrollState = UserScrollState.NOT_SCROLLED;\n  private contextMenus?: DataGridContextMenusConfiguration = undefined;\n  private currentResize: {\n    rightCellCol: HTMLTableColElement,\n    leftCellCol: HTMLTableColElement,\n    leftCellColInitialPercentageWidth: number,\n    rightCellColInitialPercentageWidth: number,\n    initialLeftCellWidth: number,\n    initialRightCellWidth: number,\n    initialMouseX: number,\n    documentForCursorChange: Document,\n    cursorToRestore: string,\n  }|null = null;\n  // Because we only render a subset of rows, we need a way to look up the\n  // actual row index from the original dataset. We could use this.rows[index]\n  // but that's O(n) and will slow as the dataset grows. A weakmap makes the\n  // lookup constant.\n  private readonly rowIndexMap = new WeakMap<Row, number>();\n  private readonly resizeObserver = new ResizeObserver(() => {\n    this.alignScrollHandlers();\n  });\n\n  // These have to be bound as they are put onto the global document, not onto\n  // this element, so LitHtml does not bind them for us.\n  private boundOnResizePointerUp = this.onResizePointerUp.bind(this);\n  private boundOnResizePointerMove = this.onResizePointerMove.bind(this);\n  private boundOnResizePointerDown = this.onResizePointerDown.bind(this);\n\n  /**\n   * Following guidance from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html, we\n   * allow a single cell inside the table to be focusable, such that when a user\n   * tabs in they select that cell. IMPORTANT: if the data-grid has sortable\n   * columns, the user has to be able to navigate to the headers to toggle the\n   * sort. [0,0] is considered the first cell INCLUDING the column header\n   * Therefore if a user is on the first header cell, the position is considered [0, 0],\n   * and if a user is on the first body cell, the position is considered [0, 1].\n   *\n   * We set the selectable cell to the first tbody value by default, but then on the\n   * first render if any of the columns are sortable we'll set the active cell\n   * to [0, 0].\n   */\n  private cellToFocusIfUserTabsIn: CellPosition = [0, 1];\n  private cellUserHasFocused: CellPosition|null = null;\n\n  private hasRenderedAtLeastOnce = false;\n  private userHasFocusInDataGrid = false;\n  private scheduleRender = false;\n\n  connectedCallback(): void {\n    this.shadow.adoptedStyleSheets = [dataGridStyles];\n    ComponentHelpers.SetCSSProperty.set(this, '--table-row-height', `${ROW_HEIGHT_PIXELS}px`);\n  }\n\n  get data(): DataGridData {\n    return {\n      columns: this.columns as Column[],\n      rows: this.rows as Row[],\n      activeSort: this.sortState,\n      contextMenus: this.contextMenus,\n    };\n  }\n\n  set data(data: DataGridData) {\n    this.columns = data.columns;\n    this.rows = data.rows;\n    this.rows.forEach((row, index) => {\n      this.rowIndexMap.set(row, index);\n    });\n    this.sortState = data.activeSort;\n    this.contextMenus = data.contextMenus;\n\n    /**\n     * On first render, now we have data, we can figure out which cell is the\n     * focusable cell for the table.\n     *\n     * If any columns are sortable, we pick [0, 0], which is the first cell of\n     * the columns row. However, if any columns are hidden, we adjust\n     * accordingly. e.g., if the first column is hidden, we'll set the starting\n     * index as [1, 0].\n     *\n     * If the columns aren't sortable, we pick the first visible body row as the\n     * index.\n     *\n     * We only do this on the first render; otherwise if we re-render and the\n     * user has focused a cell, this logic will reset it.\n     */\n    if (!this.hasRenderedAtLeastOnce) {\n      this.cellToFocusIfUserTabsIn = calculateFirstFocusableCell({columns: this.columns, rows: this.rows});\n    }\n\n    if (this.hasRenderedAtLeastOnce && this.userHasCellFocused()) {\n      const [selectedColIndex, selectedRowIndex] = this.tabbableCell();\n      const columnOutOfBounds = selectedColIndex > this.columns.length;\n      const rowOutOfBounds = selectedRowIndex > this.rows.length;\n\n      /** If the row or column was removed, so the user is out of bounds, we\n       * move them to the last focusable cell, which should be close to where\n       * they were. */\n      if (columnOutOfBounds || rowOutOfBounds) {\n        this.cellUserHasFocused = [\n          columnOutOfBounds ? this.columns.length : selectedColIndex,\n          rowOutOfBounds ? this.rows.length : selectedRowIndex,\n        ];\n      }\n    }\n\n    this.render();\n  }\n\n  private shouldAutoScrollToBottom(): boolean {\n    /**\n     * If the user's last scroll took them to the bottom, then we assume they\n     * want to automatically scroll.\n     */\n    if (this.userScrollState === UserScrollState.SCROLLED_TO_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * If the user does not have focus in the data grid (e.g. they haven't\n     * selected a cell), we automatically scroll, as long as the user hasn't\n     * manually scrolled the data-grid to somewhere that isn't the bottom.\n     */\n    if (!this.userHasFocusInDataGrid && this.userScrollState !== UserScrollState.MANUAL_SCROLL_NOT_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * Else, the user has focused a cell, or their last scroll action took them\n     * not to the bottom, so we assume that they don't want to be auto-scrolled.\n     */\n    return false;\n  }\n\n  private scrollToBottomIfRequired(): void {\n    if (this.hasRenderedAtLeastOnce === false || !this.shouldAutoScrollToBottom()) {\n      return;\n    }\n\n    coordinator.read(() => {\n      const wrapper = this.shadow.querySelector('.wrapping-container');\n      if (!wrapper) {\n        return;\n      }\n      const scrollHeight = wrapper.scrollHeight;\n      coordinator.scroll(() => {\n        wrapper.scrollTo(0, scrollHeight);\n      });\n    });\n  }\n\n  private engageResizeObserver(): void {\n    if (!this.hasRenderedAtLeastOnce) {\n      this.resizeObserver.observe(this.shadow.host);\n    }\n  }\n\n  private userHasCellFocused(): boolean {\n    return this.cellUserHasFocused !== null;\n  }\n\n  private getTableElementForCellUserHasFocused(): HTMLTableCellElement|null {\n    if (!this.cellUserHasFocused) {\n      return null;\n    }\n    const [columnIndex, rowIndex] = this.cellUserHasFocused;\n    const cell = this.shadow.querySelector<HTMLTableCellElement>(\n        `[data-row-index=\"${rowIndex}\"][data-col-index=\"${columnIndex}\"]`);\n    return cell;\n  }\n\n  private async focusTableCellInDOM(cell: HTMLTableCellElement): Promise<void> {\n    await coordinator.write(() => {\n      cell.focus();\n    });\n  }\n\n  private focusCellIfRequired([newColumnIndex, newRowIndex]: CellPosition): void {\n    this.userHasFocusInDataGrid = true;\n\n    if (this.cellUserHasFocused && this.cellUserHasFocused[0] === newColumnIndex &&\n        this.cellUserHasFocused[1] === newRowIndex) {\n      // The cell is already active and focused so we don't need to do anything.\n      return;\n    }\n\n    this.cellUserHasFocused = [newColumnIndex, newRowIndex];\n    this.render();\n    const tableCell = this.getTableElementForCellUserHasFocused();\n    if (!tableCell) {\n      // Return in case the cell is out of bounds and we do nothing\n      return;\n    }\n    /* The cell may already be focused if the user clicked into it, but we also\n     * add arrow key support, so in the case where we're programatically moving the\n     * focus, ensure we actually focus the cell.\n     */\n    this.focusTableCellInDOM(tableCell);\n  }\n\n  private onTableKeyDown(event: KeyboardEvent): void {\n    const key = event.key;\n\n    if (!this.cellUserHasFocused) {\n      return;\n    }\n\n    if (KEYS_TREATED_AS_CLICKS.has(key)) {\n      const [focusedColumnIndex, focusedRowIndex] = this.cellUserHasFocused;\n      const activeColumn = this.columns[focusedColumnIndex];\n      if (focusedRowIndex === 0 && activeColumn && activeColumn.sortable) {\n        this.onColumnHeaderClick(activeColumn, focusedColumnIndex);\n      }\n    }\n\n    if (!Platform.KeyboardUtilities.keyIsArrowKey(key)) {\n      return;\n    }\n\n    const nextFocusedCell = handleArrowKeyNavigation({\n      key: key,\n      currentFocusedCell: this.cellUserHasFocused,\n      columns: this.columns,\n      rows: this.rows,\n    });\n    event.preventDefault();\n    this.focusCellIfRequired(nextFocusedCell);\n  }\n\n  private onColumnHeaderClick(col: Column, index: number): void {\n    this.dispatchEvent(new ColumnHeaderClickEvent(col, index));\n  }\n\n  /**\n   * Applies the aria-sort label to a column's th.\n   * Guidance on values of attribute taken from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html.\n   */\n  private ariaSortForHeader(col: Column): string|undefined {\n    if (col.sortable && (!this.sortState || this.sortState.columnId !== col.id)) {\n      // Column is sortable but is not currently sorted\n      return 'none';\n    }\n\n    if (this.sortState && this.sortState.columnId === col.id) {\n      return this.sortState.direction === SortDirection.ASC ? 'ascending' : 'descending';\n    }\n\n    // Column is not sortable, so don't apply any label\n    return undefined;\n  }\n\n  private renderEmptyFillerRow(numberOfVisibleRows: number): LitHtml.TemplateResult {\n    const emptyCells = this.columns.map((col, colIndex) => {\n      if (!col.visible) {\n        return LitHtml.nothing;\n      }\n      const emptyCellClasses = LitHtml.Directives.classMap({\n        firstVisibleColumn: colIndex === 0,\n      });\n      return LitHtml.html`<td tabindex=\"-1\" class=${emptyCellClasses} data-filler-row-column-index=${colIndex}></td>`;\n    });\n    const emptyRowClasses = LitHtml.Directives.classMap({\n      'filler-row': true,\n      'padding-row': true,\n      'empty-table': numberOfVisibleRows === 0,\n    });\n    return LitHtml.html`<tr tabindex=\"-1\" class=${emptyRowClasses}>${emptyCells}</tr>`;\n  }\n\n  private cleanUpAfterResizeColumnComplete(): void {\n    if (!this.currentResize) {\n      return;\n    }\n    this.currentResize.documentForCursorChange.body.style.cursor = this.currentResize.cursorToRestore;\n    this.currentResize = null;\n    // Realign the scroll handlers now the table columns have been resized.\n    this.alignScrollHandlers();\n  }\n\n  private onResizePointerDown(event: PointerEvent): void {\n    if (event.buttons !== 1 || (Host.Platform.isMac() && event.ctrlKey)) {\n      // Ensure we only react to a left click drag mouse down event.\n      // On Mac we ignore Ctrl-click which can be used to bring up context menus, etc.\n      return;\n    }\n    event.preventDefault();\n    const resizerElement = event.target as HTMLElement;\n    if (!resizerElement) {\n      return;\n    }\n    const leftColumnIndex = resizerElement.dataset.columnIndex;\n    if (!leftColumnIndex) {\n      return;\n    }\n    const leftColumnIndexAsNumber = globalThis.parseInt(leftColumnIndex, 10);\n    /* To find the cell to the right we can't just go +1 as it might be hidden,\n     * so find the next index that is visible.\n     */\n    const rightColumnIndexAsNumber = this.columns.findIndex((column, index) => {\n      return index > leftColumnIndexAsNumber && column.visible === true;\n    });\n\n    const leftCell = this.shadow.querySelector(`td[data-filler-row-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCell = this.shadow.querySelector(`td[data-filler-row-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCell || !rightCell) {\n      return;\n    }\n    // We query for the <col> elements as they are the elements that we put the actual width on.\n    const leftCellCol =\n        this.shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCellCol =\n        this.shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCellCol || !rightCellCol) {\n      return;\n    }\n\n    const targetDocumentForCursorChange = (event.target as Node).ownerDocument;\n    if (!targetDocumentForCursorChange) {\n      return;\n    }\n    // We now store values that we'll make use of in the mousemouse event to calculate how much to resize the table by.\n    this.currentResize = {\n      leftCellCol,\n      rightCellCol,\n      leftCellColInitialPercentageWidth: globalThis.parseInt(leftCellCol.style.width, 10),\n      rightCellColInitialPercentageWidth: globalThis.parseInt(rightCellCol.style.width, 10),\n      initialLeftCellWidth: leftCell.clientWidth,\n      initialRightCellWidth: rightCell.clientWidth,\n      initialMouseX: event.x,\n      documentForCursorChange: targetDocumentForCursorChange,\n      cursorToRestore: resizerElement.style.cursor,\n    };\n\n    targetDocumentForCursorChange.body.style.cursor = 'col-resize';\n    resizerElement.setPointerCapture(event.pointerId);\n    resizerElement.addEventListener('pointermove', this.boundOnResizePointerMove);\n  }\n\n  private onResizePointerMove(event: PointerEvent): void {\n    event.preventDefault();\n    if (!this.currentResize) {\n      return;\n    }\n\n    const MIN_CELL_WIDTH_PERCENTAGE = 10;\n    const MAX_CELL_WIDTH_PERCENTAGE =\n        (this.currentResize.leftCellColInitialPercentageWidth + this.currentResize.rightCellColInitialPercentageWidth) -\n        MIN_CELL_WIDTH_PERCENTAGE;\n    const deltaOfMouseMove = event.x - this.currentResize.initialMouseX;\n    const absoluteDelta = Math.abs(deltaOfMouseMove);\n    const percentageDelta =\n        (absoluteDelta / (this.currentResize.initialLeftCellWidth + this.currentResize.initialRightCellWidth)) * 100;\n\n    let newLeftColumnPercentage;\n    let newRightColumnPercentage;\n    if (deltaOfMouseMove > 0) {\n      /**\n       * A positive delta means the user moved their mouse to the right, so we\n       * want to make the right column smaller, and the left column larger.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.currentResize.leftCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.currentResize.rightCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    } else if (deltaOfMouseMove < 0) {\n      /**\n       * Negative delta means the user moved their mouse to the left, which\n       * means we want to make the right column larger, and the left column\n       * smaller.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.currentResize.leftCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.currentResize.rightCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    }\n\n    if (!newLeftColumnPercentage || !newRightColumnPercentage) {\n      // The delta was 0, so nothing to do.\n      return;\n    }\n\n    // We limit the values to two decimal places to not work with huge decimals.\n    // It also prevents stuttering if the user barely moves the mouse, as the\n    // browser won't try to move the column by 0.0000001% or similar.\n    this.currentResize.leftCellCol.style.width = newLeftColumnPercentage.toFixed(2) + '%';\n    this.currentResize.rightCellCol.style.width = newRightColumnPercentage.toFixed(2) + '%';\n  }\n\n  private onResizePointerUp(event: PointerEvent): void {\n    event.preventDefault();\n    const resizer = event.target as HTMLElement;\n    if (!resizer) {\n      return;\n    }\n    resizer.releasePointerCapture(event.pointerId);\n    resizer.removeEventListener('pointermove', this.boundOnResizePointerMove);\n    this.cleanUpAfterResizeColumnComplete();\n  }\n\n  private renderResizeForCell(column: Column, position: CellPosition): LitHtml.TemplateResult|typeof LitHtml.nothing {\n    /**\n     * A resizer for a column is placed at the far right of the _previous column\n     * cell_. So when we get called with [1, 0] that means this dragger is\n     * resizing column 1, but the dragger itself is located within column 0. We\n     * need the column to the left because when you resize a column you're not\n     * only resizing it but also the column to its left.\n     */\n    const [columnIndex] = position;\n    const lastVisibleColumnIndex = this.getIndexOfLastVisibleColumn();\n    // If we are in the very last column, there is no column to the right to resize, so don't render a resizer.\n    if (columnIndex === lastVisibleColumnIndex || !column.visible) {\n      return LitHtml.nothing;\n    }\n\n    return LitHtml.html`<span class=\"cell-resize-handle\"\n     @pointerdown=${this.boundOnResizePointerDown}\n     @pointerup=${this.boundOnResizePointerUp}\n     data-column-index=${columnIndex}\n    ></span>`;\n  }\n\n  private getIndexOfLastVisibleColumn(): number {\n    let index = this.columns.length - 1;\n    for (; index > -1; index--) {\n      const col = this.columns[index];\n      if (col.visible) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * This function is called when the user right clicks on the header row of the\n   * data grid.\n   */\n  private onHeaderContextMenu(event: MouseEvent): void {\n    if (event.button !== 2) {\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    addColumnVisibilityCheckboxes(this, menu);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy));\n    addSortableColumnItems(this, sortMenu);\n\n    menu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    });\n\n    if (this.contextMenus && this.contextMenus.headerRow) {\n      // Let the user append things to the menu\n      this.contextMenus.headerRow(menu, this.columns);\n    }\n    menu.show();\n  }\n\n  private onBodyRowContextMenu(event: MouseEvent): void {\n    if (event.button !== 2) {\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n    /**\n     * We now make sure that the event came from an HTML element with a\n     * data-row-index attribute, else we bail.\n     */\n    if (!event.target || !(event.target instanceof HTMLElement)) {\n      return;\n    }\n    const rowIndexAttribute = event.target.dataset.rowIndex;\n    if (!rowIndexAttribute) {\n      return;\n    }\n\n    const rowIndex = parseInt(rowIndexAttribute, 10);\n    // rowIndex - 1 here because in the UI the 0th row is the column headers.\n    const rowThatWasClicked = this.rows[rowIndex - 1];\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy));\n    addSortableColumnItems(this, sortMenu);\n\n    const headerOptionsMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.headerOptions));\n    addColumnVisibilityCheckboxes(this, headerOptionsMenu);\n    headerOptionsMenu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    });\n\n    if (this.contextMenus && this.contextMenus.bodyRow) {\n      this.contextMenus.bodyRow(menu, this.columns, rowThatWasClicked);\n    }\n    menu.show();\n  }\n\n  private onScroll(event: Event): void {\n    const wrapper = event.target as HTMLElement;\n    if (!wrapper) {\n      return;\n    }\n\n    // Need to Math.round because on high res screens we can end up with decimal\n    // point numbers for scroll positions.\n    const userIsAtBottom = Math.round(wrapper.scrollTop + wrapper.clientHeight) === Math.round(wrapper.scrollHeight);\n    this.userScrollState =\n        userIsAtBottom ? UserScrollState.SCROLLED_TO_BOTTOM : UserScrollState.MANUAL_SCROLL_NOT_BOTTOM;\n\n    this.render();\n  }\n\n  private alignScrollHandlers(): Promise<void> {\n    return coordinator.read(() => {\n      const columnHeaders = this.shadow.querySelectorAll<HTMLElement>('th:not(.hidden)');\n      const handlers = this.shadow.querySelectorAll<HTMLElement>('.cell-resize-handle');\n      const table = this.shadow.querySelector<HTMLTableElement>('table');\n      if (!table) {\n        return;\n      }\n\n      columnHeaders.forEach(async (header, index) => {\n        const columnWidth = header.clientWidth;\n        const columnLeftOffset = header.offsetLeft;\n        if (handlers[index]) {\n          const handlerWidth = handlers[index].clientWidth;\n          coordinator.write(() => {\n            /**\n             * Render the resizer at the far right of the column; we subtract\n             * its width so it sits on the inner edge of the column.\n             */\n            handlers[index].style.left = `${columnLeftOffset + columnWidth - handlerWidth}px`;\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculates the index of the first row we want to render, and the last row we want to render.\n   * Pads in each direction by PADDING_ROWS_COUNT so we render some rows that are off scren.\n   */\n  private calculateTopAndBottomRowIndexes(): Promise<{topVisibleRow: number, bottomVisibleRow: number}> {\n    return coordinator.read(() => {\n      const wrapper = this.shadow.querySelector('.wrapping-container');\n\n      // On first render we don't have a wrapper, so we can't get at its\n      // scroll/height values. So we default to the inner height of the window as\n      // the limit for rendering. This means we may over-render by a few rows, but\n      // better that than either render everything, or rendering too few rows.\n      let scrollTop = 0;\n      let clientHeight = window.innerHeight;\n      if (wrapper) {\n        scrollTop = wrapper.scrollTop;\n        clientHeight = wrapper.clientHeight;\n      }\n      const padding = ROW_HEIGHT_PIXELS * PADDING_ROWS_COUNT;\n      let topVisibleRow = Math.floor((scrollTop - padding) / ROW_HEIGHT_PIXELS);\n      let bottomVisibleRow = Math.ceil((scrollTop + clientHeight + padding) / ROW_HEIGHT_PIXELS);\n\n      topVisibleRow = Math.max(0, topVisibleRow);\n      bottomVisibleRow = Math.min(this.rows.filter(r => !r.hidden).length, bottomVisibleRow);\n\n      return {\n        topVisibleRow,\n        bottomVisibleRow,\n      };\n    });\n  }\n\n  private onFocusOut(): void {\n    /**\n     * When any element in the data-grid loses focus, we set this to false. If\n     * the user then focuses another cell, that code will set the focus to true.\n     * We need to know if the user is focused because if they are and they've\n     * scrolled their focused cell out of rendering view and back in, we want to\n     * refocus it. But if they aren't focused and that happens, we don't, else\n     * we can steal focus away from the user if they are typing into an input\n     * box to filter the data-grid, for example.\n     */\n    this.userHasFocusInDataGrid = false;\n  }\n\n  private tabbableCell(): CellPosition {\n    /**\n     * If the user has selected a cell, this is the cell that should be\n     * \"tabbable\" if the user tabs out and into the data-grid. If the user\n     * hasn't selected a cell, we fallback to the default cell that we set as\n     * tabbable when we render.\n     */\n    return this.cellUserHasFocused || this.cellToFocusIfUserTabsIn;\n  }\n\n  /**\n   * Renders the data-grid table. Note that we do not render all rows; the\n   * performance cost are too high once you have a large enough table. Instead\n   * we calculate the size of the container we are rendering into, and then\n   * render only the rows required to fill that table (plus a bit extra for\n   * padding).\n   */\n  private async render(): Promise<void> {\n    if (this.isRendering) {\n      // If we receive a request to render during a previous render call, we block\n      // the newly requested render (since we could receive a lot of them in quick\n      // succession), but we do ensure that at the end of the current render we\n      // go again with the latest data.\n      this.scheduleRender = true;\n      return;\n    }\n    this.isRendering = true;\n\n    const {topVisibleRow, bottomVisibleRow} = await this.calculateTopAndBottomRowIndexes();\n    const nonHiddenRows = this.rows.filter(row => !row.hidden);\n    const renderableRows = nonHiddenRows.filter((_, idx) => idx >= topVisibleRow && idx <= bottomVisibleRow);\n    const indexOfFirstVisibleColumn = this.columns.findIndex(col => col.visible);\n    const anyColumnsSortable = this.columns.some(col => col.sortable === true);\n\n    await coordinator.write(() => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(LitHtml.html`\n      ${this.columns.map((col, columnIndex) => {\n        /**\n        * We render the resizers outside of the table. One is rendered for each\n        * column, and they are positioned absolutely at the right position. They\n        * have 100% height so they sit over the entire table and can be grabbed\n        * by the user.\n        */\n        return this.renderResizeForCell(col, [columnIndex, 0]);\n      })}\n      <div class=\"wrapping-container\" @scroll=${this.onScroll} @focusout=${this.onFocusOut}>\n        <table\n          aria-rowcount=${this.rows.length}\n          aria-colcount=${this.columns.length}\n          @keydown=${this.onTableKeyDown}\n        >\n          <colgroup>\n            ${this.columns.map((col, colIndex) => {\n              const width = calculateColumnWidthPercentageFromWeighting(this.columns, col.id);\n              const style = `width: ${width}%`;\n              if (!col.visible) {\n                return LitHtml.nothing;\n              }\n              return LitHtml.html`<col style=${style} data-col-column-index=${colIndex}>`;\n            })}\n          </colgroup>\n          <thead>\n            <tr @contextmenu=${this.onHeaderContextMenu}>\n              ${this.columns.map((col, columnIndex) => {\n                const thClasses = LitHtml.Directives.classMap({\n                  hidden: !col.visible,\n                  firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                });\n                const tabbableCell = this.tabbableCell();\n                const cellIsFocusableCell = anyColumnsSortable && columnIndex === tabbableCell[0] && tabbableCell[1] === 0;\n\n                return LitHtml.html`<th class=${thClasses}\n                  data-grid-header-cell=${col.id}\n                  @focus=${(): void => {\n                    this.focusCellIfRequired([columnIndex, 0]);\n                  }}\n                  @click=${(): void => {\n                    /**\n                     * We use click here rather than focus because if you've\n                     * clicked on the header to sort, you've also focused it. If\n                     * you then click it again to change the sorting, this\n                     * doesn't emit a focus event as the cell is already\n                     * focused.\n                     */\n                    this.onColumnHeaderClick(col, columnIndex);\n                  }}\n                  title=${col.title}\n                  aria-sort=${LitHtml.Directives.ifDefined(this.ariaSortForHeader(col))}\n                  aria-colindex=${columnIndex + 1}\n                  data-row-index='0'\n                  data-col-index=${columnIndex}\n                  tabindex=${LitHtml.Directives.ifDefined(anyColumnsSortable ? (cellIsFocusableCell ? '0' : '-1') : undefined)}\n                >${col.title}</th>`;\n              })}\n            </tr>\n          </thead>\n          <tbody>\n            <tr class=\"filler-row-top padding-row\" style=${LitHtml.Directives.styleMap({\n              height: `${topVisibleRow * ROW_HEIGHT_PIXELS}px`,\n            })}></tr>\n            ${LitHtml.Directives.repeat(renderableRows, row => this.rowIndexMap.get(row), (row): LitHtml.TemplateResult => {\n              const rowIndex = this.rowIndexMap.get(row);\n              if (rowIndex === undefined) {\n                throw new Error('Trying to render a row that has no index in the rowIndexMap');\n              }\n              const tabbableCell = this.tabbableCell();\n              // Remember that row 0 is considered the header row, so the first tbody row is row 1.\n              const tableRowIndex = rowIndex + 1;\n\n              // Check for cellUserHasFocused instead of tabbableCell so that we\n              // don't highlight the active cell before they've even clicked it.\n              const rowIsSelected = this.cellUserHasFocused ? tableRowIndex === this.cellUserHasFocused[1] : false;\n\n              const rowClasses = LitHtml.Directives.classMap({\n                selected: rowIsSelected,\n                hidden: row.hidden === true,\n              });\n              return LitHtml.html`\n                <tr\n                  aria-rowindex=${rowIndex + 1}\n                  class=${rowClasses}\n                  style=${LitHtml.Directives.ifDefined(row.styles ? LitHtml.Directives.styleMap(row.styles) : undefined)}\n                  @contextmenu=${this.onBodyRowContextMenu}\n                >${this.columns.map((col, columnIndex) => {\n                  const cell = getRowEntryForColumnId(row, col.id);\n                  const cellClasses = LitHtml.Directives.classMap({\n                    hidden: !col.visible,\n                    firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                  });\n                  const cellIsFocusableCell = columnIndex === tabbableCell[0] && tableRowIndex === tabbableCell[1];\n                  const cellOutput = col.visible ? renderCellValue(cell) : null;\n                  return LitHtml.html`<td\n                    class=${cellClasses}\n                    tabindex=${cellIsFocusableCell ? '0' : '-1'}\n                    aria-colindex=${columnIndex + 1}\n                    title=${cell.title || String(cell.value).substr(0, 20)}\n                    data-row-index=${tableRowIndex}\n                    data-col-index=${columnIndex}\n                    data-grid-value-cell-for-column=${col.id}\n                    @focus=${(): void => {\n                      this.focusCellIfRequired([columnIndex, tableRowIndex]);\n                      this.dispatchEvent(new BodyCellFocusedEvent(cell, row));\n                    }}\n                  >${cellOutput}</td>`;\n                })}\n              `;\n            })}\n            ${this.renderEmptyFillerRow(renderableRows.length)}\n            <tr class=\"filler-row-bottom padding-row\" style=${LitHtml.Directives.styleMap({\n              height: `${Math.max(0, nonHiddenRows.length - bottomVisibleRow) * ROW_HEIGHT_PIXELS}px`,\n            })}></tr>\n          </tbody>\n        </table>\n      </div>\n      `, this.shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n\n    // This ensures if the user has a cell focused, but then scrolls so that\n    // the focused cell is now not rendered, that when it then gets scrolled\n    // back in, that it becomes rendered.\n    // However, if the cell is a column header, we don't do this, as that\n    // can never be not-rendered.\n    const tabbableCell = this.tabbableCell();\n    const currentlyFocusedRowIndex = tabbableCell[1];\n    const tabbableCellElement = this.getTableElementForCellUserHasFocused();\n    if (this.userHasFocusInDataGrid && currentlyFocusedRowIndex > 0 && tabbableCellElement) {\n      this.focusTableCellInDOM(tabbableCellElement);\n    }\n    this.scrollToBottomIfRequired();\n    this.engageResizeObserver();\n    this.isRendering = false;\n    this.hasRenderedAtLeastOnce = true;\n\n    // If we've received more data mid-render we will do one extra render at\n    // the end with the most recent data.\n    if (this.scheduleRender) {\n      this.scheduleRender = false;\n      this.render();\n    }\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-data-grid', DataGrid);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-data-grid': DataGrid;\n  }\n}\n"]}